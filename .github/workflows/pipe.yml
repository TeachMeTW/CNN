name: CI/CD Pipeline

on:
  push:
    branches:
      - main

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      # Step 0: Free up disk space
      - name: Free up Disk Space on GitHub Runner
        run: |
          echo "Cleaning up unused Docker resources..."
          sudo docker system prune -af --volumes || true
          echo "Removing temporary files and caches..."
          sudo rm -rf /tmp/* $HOME/.cache/* $HOME/.npm $HOME/.pip $HOME/.cargo || true
          echo "Unmounting /mnt to free space..."
          sudo umount /mnt || true
          sudo rm -rf /mnt || true

      # Step 1: Checkout the repository
      - name: Checkout Code
        uses: actions/checkout@v3

      # Step 2: Set up Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      # Step 3: Log in to Docker Hub
      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # Step 4: Build and push Docker image with specific tag (using Git SHA)
      - name: Build and Push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/streamlit:${{ github.sha }}

      # Step 5: Set up SSH
      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      # Step 6: Deploy to EC2 via SSH
      - name: Deploy to EC2
        run: |
          # We will define $SHA_TAG so that docker-compose can pick it up if needed.
          SHA_TAG=${{ github.sha }}

          # 1) Copy the .env (stored in DOTENV_FILE) over to the EC2 instance:
          echo "${{ secrets.DOTENV_FILE }}" > .env
          # If your .env is truly multiline, make sure everything is properly stored.
          # Some prefer using base64-encoded secrets; this approach also works if your secret is multiline.
          
          scp -o StrictHostKeyChecking=no .env ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }}:~/CNN/.env
          rm .env

          # 2) SSH into instance to run docker-compose
          ssh -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
            set -xe

            # Navigate to repository directory
            cd ~/CNN || { echo "Repository directory not found!"; exit 1; }

            # Clean up old Docker stuff (optional, same as before)
            containers=$(sudo docker ps -aq)
            if [ -n "$containers" ]; then
              sudo docker stop $containers || true
              sudo docker rm $containers || true
            fi

            images=$(sudo docker images -q)
            if [ -n "$images" ]; then
              sudo docker rmi $images || true
            fi

            sudo docker system prune -af --volumes || true

            # Pull the latest code from main (if you still keep the code on the server)
            git pull origin main

            # (Optionally) export environment variable for the Docker tag if your docker-compose.yml references it
            export SHA_TAG=${SHA_TAG}

            # Pull the new images (especially if your streamlit service uses an external image)
            sudo docker-compose pull

            # Launch the services in detached mode
            sudo docker-compose up -d

            # Basic health check
            sleep 10
            if ! curl -f http://localhost:8501; then
              echo "Health check failed!"
              # Optionally revert or handle errors
              sudo docker-compose logs
              exit 1
            fi

            # Restart Nginx if you are fronting your containers with Nginx
            sudo systemctl restart nginx || true

            echo "Deployment completed successfully."
          EOF
